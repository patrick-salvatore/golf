// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scores.sql

package db

import (
	"context"
	"database/sql"
)

const getScoreByUniqueKey = `-- name: GetScoreByUniqueKey :one
SELECT id FROM scores 
WHERE tournament_id = ?1
  AND IFNULL(player_id, -1) = IFNULL(?2, -1)
  AND IFNULL(team_id, -1) = IFNULL(?3, -1)
  AND course_hole_id = ?4
`

type GetScoreByUniqueKeyParams struct {
	TournamentID int64
	PlayerID     interface{}
	TeamID       interface{}
	CourseHoleID int64
}

func (q *Queries) GetScoreByUniqueKey(ctx context.Context, arg GetScoreByUniqueKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getScoreByUniqueKey,
		arg.TournamentID,
		arg.PlayerID,
		arg.TeamID,
		arg.CourseHoleID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getScores = `-- name: GetScores :many
SELECT s.id, s.tournament_id, s.player_id, s.team_id, s.course_hole_id, s.strokes, s.created_at, ch.hole_number
FROM scores s
JOIN course_holes ch ON s.course_hole_id = ch.id
WHERE s.tournament_id = ?
  AND (?2 IS NULL OR s.player_id = ?2)
  AND (?3 IS NULL OR s.team_id = ?3)
`

type GetScoresParams struct {
	TournamentID int64
	PlayerID     interface{}
	TeamID       interface{}
}

type GetScoresRow struct {
	ID           int64
	TournamentID int64
	PlayerID     sql.NullInt64
	TeamID       sql.NullInt64
	CourseHoleID int64
	Strokes      int64
	CreatedAt    sql.NullTime
	HoleNumber   int64
}

func (q *Queries) GetScores(ctx context.Context, arg GetScoresParams) ([]GetScoresRow, error) {
	rows, err := q.db.QueryContext(ctx, getScores, arg.TournamentID, arg.PlayerID, arg.TeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoresRow
	for rows.Next() {
		var i GetScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.PlayerID,
			&i.TeamID,
			&i.CourseHoleID,
			&i.Strokes,
			&i.CreatedAt,
			&i.HoleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertScore = `-- name: InsertScore :one
INSERT INTO scores (tournament_id, player_id, team_id, course_hole_id, strokes, created_at)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertScoreParams struct {
	TournamentID int64
	PlayerID     sql.NullInt64
	TeamID       sql.NullInt64
	CourseHoleID int64
	Strokes      int64
	CreatedAt    sql.NullTime
}

func (q *Queries) InsertScore(ctx context.Context, arg InsertScoreParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertScore,
		arg.TournamentID,
		arg.PlayerID,
		arg.TeamID,
		arg.CourseHoleID,
		arg.Strokes,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateScore = `-- name: UpdateScore :exec
UPDATE scores SET strokes = ? WHERE id = ?
`

type UpdateScoreParams struct {
	Strokes int64
	ID      int64
}

func (q *Queries) UpdateScore(ctx context.Context, arg UpdateScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateScore, arg.Strokes, arg.ID)
	return err
}
