// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package models

import (
	"context"
	"database/sql"
)

const addPlayerToTeam = `-- name: AddPlayerToTeam :exec
INSERT INTO team_players (team_id, player_id) VALUES (?, ?)
`

type AddPlayerToTeamParams struct {
	TeamID   sql.NullInt64
	PlayerID sql.NullInt64
}

func (q *Queries) AddPlayerToTeam(ctx context.Context, arg AddPlayerToTeamParams) error {
	_, err := q.db.ExecContext(ctx, addPlayerToTeam, arg.TeamID, arg.PlayerID)
	return err
}

const checkTeamExists = `-- name: CheckTeamExists :one
SELECT EXISTS(SELECT 1 FROM teams WHERE id = ? AND tournament_id = ?)
`

type CheckTeamExistsParams struct {
	ID           int64
	TournamentID sql.NullInt64
}

func (q *Queries) CheckTeamExists(ctx context.Context, arg CheckTeamExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkTeamExists, arg.ID, arg.TournamentID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createInvite = `-- name: CreateInvite :one
INSERT INTO invites (token, tournament_id, team_id, expires_at, created_at, active)
VALUES (?, ?, ?, ?, ?, 1)
RETURNING token, tournament_id, team_id, expires_at, created_at, active
`

type CreateInviteParams struct {
	Token        sql.NullString
	TournamentID int64
	TeamID       sql.NullInt64
	ExpiresAt    sql.NullTime
	CreatedAt    sql.NullTime
}

type CreateInviteRow struct {
	Token        sql.NullString
	TournamentID int64
	TeamID       sql.NullInt64
	ExpiresAt    sql.NullTime
	CreatedAt    sql.NullTime
	Active       sql.NullBool
}

func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) (CreateInviteRow, error) {
	row := q.db.QueryRowContext(ctx, createInvite,
		arg.Token,
		arg.TournamentID,
		arg.TeamID,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	var i CreateInviteRow
	err := row.Scan(
		&i.Token,
		&i.TournamentID,
		&i.TeamID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Active,
	)
	return i, err
}

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (name, handicap, is_admin, created_at) 
VALUES (?, ?, ?, ?) 
RETURNING id, name, handicap, is_admin, created_at
`

type CreatePlayerParams struct {
	Name      string
	Handicap  sql.NullFloat64
	IsAdmin   sql.NullBool
	CreatedAt sql.NullTime
}

type CreatePlayerRow struct {
	ID        int64
	Name      string
	Handicap  sql.NullFloat64
	IsAdmin   sql.NullBool
	CreatedAt sql.NullTime
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (CreatePlayerRow, error) {
	row := q.db.QueryRowContext(ctx, createPlayer,
		arg.Name,
		arg.Handicap,
		arg.IsAdmin,
		arg.CreatedAt,
	)
	var i CreatePlayerRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handicap,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (name, tournament_id, started, finished, created_at) 
VALUES (?, ?, 0, 0, ?)
RETURNING id
`

type CreateTeamParams struct {
	Name         string
	TournamentID sql.NullInt64
	CreatedAt    sql.NullTime
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createTeam, arg.Name, arg.TournamentID, arg.CreatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTournament = `-- name: CreateTournament :one
INSERT INTO tournaments (name, course_id, format_id, team_count, awarded_handicap, is_match_play, start_time, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, course_id, format_id, team_count, awarded_handicap, is_match_play, complete, start_time, created_at
`

type CreateTournamentParams struct {
	Name            string
	CourseID        sql.NullInt64
	FormatID        sql.NullInt64
	TeamCount       sql.NullInt64
	AwardedHandicap sql.NullFloat64
	IsMatchPlay     sql.NullBool
	StartTime       sql.NullTime
	CreatedAt       sql.NullTime
}

type CreateTournamentRow struct {
	ID              int64
	Name            string
	CourseID        sql.NullInt64
	FormatID        sql.NullInt64
	TeamCount       sql.NullInt64
	AwardedHandicap sql.NullFloat64
	IsMatchPlay     sql.NullBool
	Complete        sql.NullBool
	StartTime       sql.NullTime
	CreatedAt       sql.NullTime
}

func (q *Queries) CreateTournament(ctx context.Context, arg CreateTournamentParams) (CreateTournamentRow, error) {
	row := q.db.QueryRowContext(ctx, createTournament,
		arg.Name,
		arg.CourseID,
		arg.FormatID,
		arg.TeamCount,
		arg.AwardedHandicap,
		arg.IsMatchPlay,
		arg.StartTime,
		arg.CreatedAt,
	)
	var i CreateTournamentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CourseID,
		&i.FormatID,
		&i.TeamCount,
		&i.AwardedHandicap,
		&i.IsMatchPlay,
		&i.Complete,
		&i.StartTime,
		&i.CreatedAt,
	)
	return i, err
}

const getAllCourses = `-- name: GetAllCourses :many
SELECT id, name FROM courses
`

type GetAllCoursesRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetAllCourses(ctx context.Context) ([]GetAllCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCoursesRow
	for rows.Next() {
		var i GetAllCoursesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFormats = `-- name: GetAllFormats :many
SELECT id, name, description FROM tournament_formats ORDER BY name
`

type GetAllFormatsRow struct {
	ID          int64
	Name        string
	Description sql.NullString
}

func (q *Queries) GetAllFormats(ctx context.Context) ([]GetAllFormatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllFormats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFormatsRow
	for rows.Next() {
		var i GetAllFormatsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPlayers = `-- name: GetAllPlayers :many
SELECT id, name, handicap, is_admin, created_at FROM players ORDER BY name
`

type GetAllPlayersRow struct {
	ID        int64
	Name      string
	Handicap  sql.NullFloat64
	IsAdmin   sql.NullBool
	CreatedAt sql.NullTime
}

func (q *Queries) GetAllPlayers(ctx context.Context) ([]GetAllPlayersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPlayersRow
	for rows.Next() {
		var i GetAllPlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Handicap,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTournaments = `-- name: GetAllTournaments :many
SELECT id, name, course_id, format_id, team_count, awarded_handicap, is_match_play, complete, start_time, created_at 
FROM tournaments ORDER BY created_at DESC
`

type GetAllTournamentsRow struct {
	ID              int64
	Name            string
	CourseID        sql.NullInt64
	FormatID        sql.NullInt64
	TeamCount       sql.NullInt64
	AwardedHandicap sql.NullFloat64
	IsMatchPlay     sql.NullBool
	Complete        sql.NullBool
	StartTime       sql.NullTime
	CreatedAt       sql.NullTime
}

func (q *Queries) GetAllTournaments(ctx context.Context) ([]GetAllTournamentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTournamentsRow
	for rows.Next() {
		var i GetAllTournamentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CourseID,
			&i.FormatID,
			&i.TeamCount,
			&i.AwardedHandicap,
			&i.IsMatchPlay,
			&i.Complete,
			&i.StartTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailablePlayerById = `-- name: GetAvailablePlayerById :one
SELECT player_id, tournament_id, created_at FROM active_tournament_players WHERE tournament_id = ? AND player_id = ?
`

type GetAvailablePlayerByIdParams struct {
	TournamentID int64
	PlayerID     int64
}

type GetAvailablePlayerByIdRow struct {
	PlayerID     int64
	TournamentID int64
	CreatedAt    sql.NullTime
}

func (q *Queries) GetAvailablePlayerById(ctx context.Context, arg GetAvailablePlayerByIdParams) (GetAvailablePlayerByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getAvailablePlayerById, arg.TournamentID, arg.PlayerID)
	var i GetAvailablePlayerByIdRow
	err := row.Scan(&i.PlayerID, &i.TournamentID, &i.CreatedAt)
	return i, err
}

const getAvailablePlayers = `-- name: GetAvailablePlayers :many
SELECT p.id, p.name, p.handicap 
FROM players p
JOIN team_players tp ON tp.player_id = p.id
JOIN teams t ON t.id = tp.team_id
WHERE t.tournament_id = ?
AND p.id NOT IN (
    SELECT atp.player_id FROM active_tournament_players atp WHERE atp.tournament_id = ?
)
ORDER BY p.name
`

type GetAvailablePlayersParams struct {
	TournamentID   sql.NullInt64
	TournamentID_2 int64
}

type GetAvailablePlayersRow struct {
	ID       int64
	Name     string
	Handicap sql.NullFloat64
}

func (q *Queries) GetAvailablePlayers(ctx context.Context, arg GetAvailablePlayersParams) ([]GetAvailablePlayersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailablePlayers, arg.TournamentID, arg.TournamentID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailablePlayersRow
	for rows.Next() {
		var i GetAvailablePlayersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Handicap); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseByTournamentID = `-- name: GetCourseByTournamentID :one
SELECT c.id, c.name
FROM courses c
JOIN tournaments t ON t.course_id = c.id
WHERE t.id = ?
`

type GetCourseByTournamentIDRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetCourseByTournamentID(ctx context.Context, id int64) (GetCourseByTournamentIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseByTournamentID, id)
	var i GetCourseByTournamentIDRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getCourseHoles = `-- name: GetCourseHoles :many
SELECT id, hole_number, par, handicap, hole_index, yardage 
FROM course_holes 
WHERE course_id = ? AND tee_set = 'Mens' 
ORDER BY hole_number ASC
`

type GetCourseHolesRow struct {
	ID         int64
	HoleNumber int64
	Par        int64
	Handicap   int64
	HoleIndex  sql.NullInt64
	Yardage    int64
}

func (q *Queries) GetCourseHoles(ctx context.Context, courseID int64) ([]GetCourseHolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourseHoles, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseHolesRow
	for rows.Next() {
		var i GetCourseHolesRow
		if err := rows.Scan(
			&i.ID,
			&i.HoleNumber,
			&i.Par,
			&i.Handicap,
			&i.HoleIndex,
			&i.Yardage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvite = `-- name: GetInvite :one
SELECT token, tournament_id, team_id, expires_at, created_at, active FROM invites WHERE token = ?
`

type GetInviteRow struct {
	Token        sql.NullString
	TournamentID int64
	TeamID       sql.NullInt64
	ExpiresAt    sql.NullTime
	CreatedAt    sql.NullTime
	Active       sql.NullBool
}

func (q *Queries) GetInvite(ctx context.Context, token sql.NullString) (GetInviteRow, error) {
	row := q.db.QueryRowContext(ctx, getInvite, token)
	var i GetInviteRow
	err := row.Scan(
		&i.Token,
		&i.TournamentID,
		&i.TeamID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Active,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, name, handicap, is_admin, created_at FROM players WHERE id = ?
`

type GetPlayerRow struct {
	ID        int64
	Name      string
	Handicap  sql.NullFloat64
	IsAdmin   sql.NullBool
	CreatedAt sql.NullTime
}

func (q *Queries) GetPlayer(ctx context.Context, id int64) (GetPlayerRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayer, id)
	var i GetPlayerRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handicap,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getScoreByUniqueKey = `-- name: GetScoreByUniqueKey :one
SELECT id FROM scores 
WHERE tournament_id = ? 
  AND IFNULL(player_id, -1) = IFNULL(?3, -1)
  AND IFNULL(team_id, -1) = IFNULL(?4, -1)
  AND id = ?
`

type GetScoreByUniqueKeyParams struct {
	TournamentID int64
	PlayerID     interface{}
	TeamID       interface{}
	CourseHoleID int64
}

func (q *Queries) GetScoreByUniqueKey(ctx context.Context, arg GetScoreByUniqueKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getScoreByUniqueKey,
		arg.TournamentID,
		arg.PlayerID,
		arg.TeamID,
		arg.CourseHoleID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getScores = `-- name: GetScores :many
SELECT s.id, s.tournament_id, s.player_id, s.team_id, s.course_hole_id, s.strokes, s.created_at, ch.hole_number
FROM scores s
JOIN course_holes ch ON s.course_hole_id = ch.id
WHERE s.tournament_id = ?
  AND (?2 IS NULL OR s.player_id = ?2)
  AND (?3 IS NULL OR s.team_id = ?3)
`

type GetScoresParams struct {
	TournamentID int64
	PlayerID     interface{}
	TeamID       interface{}
}

type GetScoresRow struct {
	ID           int64
	TournamentID int64
	PlayerID     sql.NullInt64
	TeamID       sql.NullInt64
	CourseHoleID int64
	Strokes      int64
	CreatedAt    sql.NullTime
	HoleNumber   int64
}

func (q *Queries) GetScores(ctx context.Context, arg GetScoresParams) ([]GetScoresRow, error) {
	rows, err := q.db.QueryContext(ctx, getScores, arg.TournamentID, arg.PlayerID, arg.TeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoresRow
	for rows.Next() {
		var i GetScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.PlayerID,
			&i.TeamID,
			&i.CourseHoleID,
			&i.Strokes,
			&i.CreatedAt,
			&i.HoleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
SELECT id, name, tournament_id, started, finished FROM teams WHERE id = ?
`

type GetTeamRow struct {
	ID           int64
	Name         string
	TournamentID sql.NullInt64
	Started      sql.NullBool
	Finished     sql.NullBool
}

func (q *Queries) GetTeam(ctx context.Context, id int64) (GetTeamRow, error) {
	row := q.db.QueryRowContext(ctx, getTeam, id)
	var i GetTeamRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TournamentID,
		&i.Started,
		&i.Finished,
	)
	return i, err
}

const getTeamPlayers = `-- name: GetTeamPlayers :many
SELECT p.id, p.name, p.handicap, p.is_admin, p.created_at, tp.tee
FROM players p
JOIN team_players tp ON tp.player_id = p.id
WHERE tp.team_id = ?
`

type GetTeamPlayersRow struct {
	ID        int64
	Name      string
	Handicap  sql.NullFloat64
	IsAdmin   sql.NullBool
	CreatedAt sql.NullTime
	Tee       sql.NullString
}

func (q *Queries) GetTeamPlayers(ctx context.Context, teamID sql.NullInt64) ([]GetTeamPlayersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamPlayers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamPlayersRow
	for rows.Next() {
		var i GetTeamPlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Handicap,
			&i.IsAdmin,
			&i.CreatedAt,
			&i.Tee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsByTournament = `-- name: GetTeamsByTournament :many
SELECT id, name, tournament_id, started, finished FROM teams WHERE tournament_id = ?
`

type GetTeamsByTournamentRow struct {
	ID           int64
	Name         string
	TournamentID sql.NullInt64
	Started      sql.NullBool
	Finished     sql.NullBool
}

func (q *Queries) GetTeamsByTournament(ctx context.Context, tournamentID sql.NullInt64) ([]GetTeamsByTournamentRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamsByTournament, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsByTournamentRow
	for rows.Next() {
		var i GetTeamsByTournamentRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TournamentID,
			&i.Started,
			&i.Finished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournament = `-- name: GetTournament :one
SELECT id, name, course_id, format_id, team_count, awarded_handicap, is_match_play, complete, start_time, created_at 
FROM tournaments WHERE id = ?
`

type GetTournamentRow struct {
	ID              int64
	Name            string
	CourseID        sql.NullInt64
	FormatID        sql.NullInt64
	TeamCount       sql.NullInt64
	AwardedHandicap sql.NullFloat64
	IsMatchPlay     sql.NullBool
	Complete        sql.NullBool
	StartTime       sql.NullTime
	CreatedAt       sql.NullTime
}

func (q *Queries) GetTournament(ctx context.Context, id int64) (GetTournamentRow, error) {
	row := q.db.QueryRowContext(ctx, getTournament, id)
	var i GetTournamentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CourseID,
		&i.FormatID,
		&i.TeamCount,
		&i.AwardedHandicap,
		&i.IsMatchPlay,
		&i.Complete,
		&i.StartTime,
		&i.CreatedAt,
	)
	return i, err
}

const insertScore = `-- name: InsertScore :one
INSERT INTO scores (tournament_id, player_id, team_id, course_hole_id, strokes, created_at)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id
`

type InsertScoreParams struct {
	TournamentID int64
	PlayerID     sql.NullInt64
	TeamID       sql.NullInt64
	CourseHoleID int64
	Strokes      int64
	CreatedAt    sql.NullTime
}

func (q *Queries) InsertScore(ctx context.Context, arg InsertScoreParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertScore,
		arg.TournamentID,
		arg.PlayerID,
		arg.TeamID,
		arg.CourseHoleID,
		arg.Strokes,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const removeActivePlayer = `-- name: RemoveActivePlayer :exec
DELETE FROM active_tournament_players WHERE tournament_id = ? AND player_id = ?
`

type RemoveActivePlayerParams struct {
	TournamentID int64
	PlayerID     int64
}

func (q *Queries) RemoveActivePlayer(ctx context.Context, arg RemoveActivePlayerParams) error {
	_, err := q.db.ExecContext(ctx, removeActivePlayer, arg.TournamentID, arg.PlayerID)
	return err
}

const selectPlayer = `-- name: SelectPlayer :exec
INSERT INTO active_tournament_players (tournament_id, player_id) VALUES (?, ?)
`

type SelectPlayerParams struct {
	TournamentID int64
	PlayerID     int64
}

func (q *Queries) SelectPlayer(ctx context.Context, arg SelectPlayerParams) error {
	_, err := q.db.ExecContext(ctx, selectPlayer, arg.TournamentID, arg.PlayerID)
	return err
}

const startTeam = `-- name: StartTeam :exec
UPDATE teams SET started = 1 WHERE id = ?
`

func (q *Queries) StartTeam(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, startTeam, id)
	return err
}

const updateScore = `-- name: UpdateScore :exec
UPDATE scores SET strokes = ? WHERE id = ?
`

type UpdateScoreParams struct {
	Strokes int64
	ID      int64
}

func (q *Queries) UpdateScore(ctx context.Context, arg UpdateScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateScore, arg.Strokes, arg.ID)
	return err
}
